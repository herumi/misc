#pragma once
/**
	@author herumi
	@note modified new BSD license
	http://opensource.org/licenses/BSD-3-Clause
*/
#include <xbyak_aarch64/xbyak_aarch64.h>
#include <cmath>

namespace fmath {

using namespace Xbyak_aarch64;

namespace local {

union fi {
	float f;
	uint32_t i;
};

inline float cvt(uint32_t x)
{
	fi fi;
	fi.i = x;
	return fi.f;
}

struct ConstVar {
	static const size_t expN = 5;
	static const size_t logN = 9;
	float log2; // log(2)
	float log2_e; // log_2(e) = 1 / log2
	float expCoeff[expN]; // near to 1/(i + 1)!
	//
	void init()
	{
		log2 = std::log(2.0f);
		log2_e = 1.0f / log2;
		// maxe=1.938668e-06
		const uint32_t expTbl[expN] = {
			0x3f800000,
			0x3effff12,
			0x3e2aaa56,
			0x3d2b89cc,
			0x3c091331,
		};
		for (size_t i = 0; i < expN; i++) {
			expCoeff[i] = cvt(expTbl[i]);
		}
	}
};

/*
The constans expCoeff are generated by Maple.
f := x->A+B*x+C*x^2+D*x^3+E*x^4+F*x^5;
g:=int((f(x)-exp(x))^2,x=-L..L);
sols:=solve({diff(g,A)=0,diff(g,B)=0,diff(g,C)=0,diff(g,D)=0,diff(g,E)=0,diff(g,F)=0},{A,B,C,D,E,F});
Digits:=1000;
s:=eval(sols,L=log(2)/2);
evalf(s,20);
*/
struct Code : public CodeGenerator {
	ConstVar *constVar;
	typedef void (*VecFunc)(float *dst, const float *src, size_t n);
	VecFunc expf_v;
	VecFunc tanhf_v;
//	VecFunc logf_v;
	Code()
		: CodeGenerator(4096 * 2)
		, expf_v(0)
		, tanhf_v(0)
//		, logf_v(0)
	{
		size_t dataSize = sizeof(ConstVar);
		dataSize = (dataSize + 4095) & ~size_t(4095);
		Label constVarL = L();
		constVar = (ConstVar*)getCode();
		constVar->init();
		setSize(dataSize / 4);
		expf_v = getCurr<VecFunc>();
		genExpSVE(constVarL);
		align(16);
		tanhf_v = getCurr<VecFunc>();
		genTanhSVE(constVarL);
		ready();
	}
	// tz0 = exp(tz0)
	// use tz0, tz1, tz2
	void genExp1SVE(const PReg& p, const ZReg& tz0, const ZReg& tz1, const ZReg& tz2, const ZReg& log2, const ZReg& log2_e, const ZReg expCoeff[5])
	{
		fmul(tz0.s, tz0.s, log2_e.s);
		frintn(tz2.s, p, tz0.s); // rounding : float -> float
		fcvtzs(tz1.s, p, tz2.s); // float -> int
		fsub(tz2.s, tz0.s, tz2.s);
		fmul(tz2.s, tz2.s, log2.s);
		movprfx(tz0.s, p, expCoeff[4].s);
		fmad(tz0.s, p, tz2.s, expCoeff[3].s);
		fmad(tz0.s, p, tz2.s, expCoeff[2].s);
		fmad(tz0.s, p, tz2.s, expCoeff[1].s);
		fmad(tz0.s, p, tz2.s, expCoeff[0].s);
		fmad(tz0.s, p, tz2.s, expCoeff[0].s);
		fscale(tz0.s, p, tz1.s); // tz0 *= 2^tz1
	}
	// t0 = exp(t0), tz3 = exp(t3), ...
	// use t
	template<size_t N>
	void genExpsSVE(const PReg& p, std::array<ZReg, N> t, const ZReg& log2, const ZReg& log2_e, const ZReg expCoeff[5])
	{
		const size_t n = N / 3;
		for (size_t i = 0; i < n; i++) fmul(t[0 + i * 3].s, t[0 + i * 3].s, log2_e.s);
		for (size_t i = 0; i < n; i++) frintn(t[2 + i * 3].s, p, t[0 + i * 3].s); // rounding : float -> float
		for (size_t i = 0; i < n; i++) fcvtzs(t[1 + i * 3].s, p, t[2 + i * 3].s); // float -> int
		for (size_t i = 0; i < n; i++) fsub(t[2 + i * 3].s, t[0 + i * 3].s, t[2 + i * 3].s);
		for (size_t i = 0; i < n; i++) fmul(t[2 + i * 3].s, t[2 + i * 3].s, log2.s);
		for (size_t i = 0; i < n; i++) {
			movprfx(t[0 + i * 3].s, p, expCoeff[4].s);
			fmad(t[0 + i * 3].s, p, t[2 + i * 3].s, expCoeff[3].s);
		}
		for (size_t i = 0; i < n; i++) fmad(t[0 + i * 3].s, p, t[2 + i * 3].s, expCoeff[2].s);
		for (size_t i = 0; i < n; i++) fmad(t[0 + i * 3].s, p, t[2 + i * 3].s, expCoeff[1].s);
		for (size_t i = 0; i < n; i++) fmad(t[0 + i * 3].s, p, t[2 + i * 3].s, expCoeff[0].s);
		for (size_t i = 0; i < n; i++) fmad(t[0 + i * 3].s, p, t[2 + i * 3].s, expCoeff[0].s);
		for (size_t i = 0; i < n; i++) fscale(t[0 + i * 3].s, p, t[1 + i * 3].s); // tz0 *= 2^tz1
	}
	// exp_v(float *dst, const float *src, size_t n);
	void genExpSVE(const Label& constVarL)
	{
		const XReg& dst = x0;
		const XReg& src = x1;
		const XReg& n = x2;

		// setup constant
		const ZReg& log2 = z3;
		const ZReg& log2_e = z4;
#define FMATH_SVE_LOOP_UNROLL 1
		const ZReg expCoeff[] = {
			z5, z6, z7, z24, z25,
#if FMATH_SVE_LOOP_UNROLL >= 2
			z26, z27, z28,
#endif
#if FMATH_SVE_LOOP_UNROLL >= 3
			z29, z30, z31,
#endif
		};
		ptrue(p0.s);

		adr(x3, constVarL);
		ldr(w4, ptr(x3, (uint32_t)offsetof(ConstVar, log2)));
		cpy(log2.s, p0/T_z, w4);
		ldr(w4, ptr(x3, (uint32_t)offsetof(ConstVar, log2_e)));
		cpy(log2_e.s, p0/T_z, w4);
		for (size_t i = 0; i < ConstVar::expN; i++) {
			ldr(w4, ptr(x3, uint32_t(offsetof(ConstVar, expCoeff[0]) + sizeof(float) * i)));
			cpy(expCoeff[i].s, p0/T_z, w4);
		}
#if FMATH_SVE_LOOP_UNROLL == 1
		Label skip;
		b(skip);
	Label lp = L();
		ld1w(z0.s, p0/T_z, ptr(src));
		add(src, src, 64);
		genExp1SVE(p0, z0, z1, z2, log2, log2_e, expCoeff);
		st1w(z0.s, p0, ptr(dst));
		add(dst, dst, 64);
		sub(n, n, 16);
	L(skip);
		cmp(n, 16);
		bge(lp);

#endif
#if FMATH_SVE_LOOP_UNROLL == 2
		Label skip;
		b(skip);
	Label lp = L();
		ld1w(z0.s, p0/T_z, ptr(src));
		ld1w(z12.s, p0/T_z, ptr(src, 1));
		add(src, src, 64 * 2);
		genExpsSVE(p0, std::array<ZReg, 6>{z0, z1, z2, z12, z13, z14}, log2, log2_e, expCoeff);
		st1w(z0.s, p0, ptr(dst));
		st1w(z12.s, p0, ptr(dst, 1));
		add(dst, dst, 64 * 2);
		sub(n, n, 16 * 2);
	L(skip);
		cmp(n, 16 * 2);
		bge(lp);
#endif
#if FMATH_SVE_LOOP_UNROLL == 3
		Label skip;
		b(skip);
	Label lp = L();
		ld1w(z0.s, p0/T_z, ptr(src));
		ld1w(z12.s, p0/T_z, ptr(src, 1));
		ld1w(z15.s, p0/T_z, ptr(src, 2));
		add(src, src, 64 * 3);
		genExpsSVE(p0, std::array<ZReg, 9>{z0, z1, z2, z12, z13, z14, z15, z16, z17}, log2, log2_e, expCoeff);
		st1w(z0.s, p0, ptr(dst));
		st1w(z12.s, p0, ptr(dst, 1));
		st1w(z15.s, p0, ptr(dst, 2));
		add(dst, dst, 64 * 3);
		sub(n, n, 16 * 3);
	L(skip);
		cmp(n, 16 * 3);
		bge(lp);
#endif

		Label cond;
		mov(x3, 0);
		b(cond);
	Label lp2 = L();
		ld1w(z0.s, p1/T_z, ptr(src, x3, LSL, 2));
		genExp1SVE(p1, z0, z1, z2, log2, log2_e, expCoeff);
		st1w(z0.s, p1, ptr(dst, x3, LSL, 2));
		incd(x3);
	L(cond);
		whilelt(p1.s, x3, n);
		b_first(lp2);
		ret();
	}
	// tz0 = tanh(tz0) = 1 - 2 / (1 + exp(2 tz0))
	// use tz0, tz1, tz2
	void genTanh1SVE(const PReg& p, const ZReg& tz0, const ZReg& tz1, const ZReg& tz2, const ZReg& tz3, const ZReg& log2, const ZReg& log2_e, const ZReg expCoeff[5])
	{
		// 2x
		fadd(tz0.s, tz0.s, tz0.s);
		// exp(2x)
		fmul(tz0.s, tz0.s, log2_e.s);
		frintn(tz2.s, p, tz0.s); // rounding : float -> float
		fcvtzs(tz1.s, p, tz2.s); // float -> int
		fsub(tz2.s, tz0.s, tz2.s);
		fmul(tz2.s, tz2.s, log2.s);
		movprfx(tz0.s, p, expCoeff[4].s);
		fmad(tz0.s, p, tz2.s, expCoeff[3].s);
		fmad(tz0.s, p, tz2.s, expCoeff[2].s);
		fmad(tz0.s, p, tz2.s, expCoeff[1].s);
		fmad(tz0.s, p, tz2.s, expCoeff[0].s);
		fmad(tz0.s, p, tz2.s, expCoeff[0].s);
		fscale(tz0.s, p, tz1.s); // tz0 *= 2^tz1
		// 1+exp(2x)
		fadd(tz0.s, tz0.s, expCoeff[0].s); // 1
		// 1/(1+exp(2x))
		const int mode = 2;
		switch (mode) {
		case 0:
			/*
				range [-4.00e+00, 4.00e+00] step=1.00e-05
				maxe2=2.682209e-07 (x=-5.196900e-01)
				ave=-3.176198e-08
			*/
			movprfx(tz0.s, p, expCoeff[0].s);
			fdiv(tz0.s, p, tz0.s);
			break;
		case 1:
		default:
			/*
				range [-4.00e+00, 4.00e+00] step=1.00e-05
				maxe2=1.537800e-05 (x=-1.674076e+00)
				ave=7.123578e-07
			*/
			frecpe(tz1.s, tz0.s);
			frecps(tz0.s, tz0.s, tz1.s);
			fmul(tz0.s, tz0.s, tz1.s);
			break;
		case 2:
			/*
				range [-4.00e+00, 4.00e+00] step=1.00e-05
				maxe2=2.980232e-07 (x=-2.439293e+00)
				ave=-3.302310e-08
			*/
			// 1st aprox ; a = 1/x + e
			frecpe(tz1.s, tz0.s);
			// 2nd aprox ; a' = (2 - ax)a = 1/x - e^2 x
			frecps(tz3.s, tz0.s, tz1.s); // use tz3 instead of tz2
			fmul(tz3.s, tz3.s, tz1.s);
			// 3rd aprox ; a'' = (2 - a'x)a'
			frecps(tz0.s, tz0.s, tz3.s);
			fmul(tz0.s, tz0.s, tz3.s);
		}
		// 2/(1+exp(2x))
		fadd(tz0.s, tz0.s, tz0.s);
		// 1-2/(1+exp(2x))
		fsub(tz0.s, expCoeff[0].s, tz0.s);
	}
	// tanhf_v(float *dst, const float *src, size_t n);
	void genTanhSVE(const Label& constVarL)
	{
		const XReg& dst = x0;
		const XReg& src = x1;
		const XReg& n = x2;

		// setup constant
		const ZReg& log2 = z4;
		const ZReg& log2_e = z5;
		const ZReg expCoeff[] = {
			z6, z7, z24, z25, z26,
		};
		ptrue(p0.s);

		adr(x3, constVarL);
		ldr(w4, ptr(x3, (uint32_t)offsetof(ConstVar, log2)));
		cpy(log2.s, p0/T_z, w4);
		ldr(w4, ptr(x3, (uint32_t)offsetof(ConstVar, log2_e)));
		cpy(log2_e.s, p0/T_z, w4);
		for (size_t i = 0; i < ConstVar::expN; i++) {
			ldr(w4, ptr(x3, uint32_t(offsetof(ConstVar, expCoeff[0]) + sizeof(float) * i)));
			cpy(expCoeff[i].s, p0/T_z, w4);
		}
		Label skip;
		b(skip);
	Label lp = L();
		ld1w(z0.s, p0/T_z, ptr(src));
		add(src, src, 64);
		genTanh1SVE(p0, z0, z1, z2, z3, log2, log2_e, expCoeff);
		st1w(z0.s, p0, ptr(dst));
		add(dst, dst, 64);
		sub(n, n, 16);
	L(skip);
		cmp(n, 16);
		bge(lp);

		mov(x3, 0);
		whilelt(p1.s, x3, n);
		ld1w(z0.s, p1/T_z, ptr(src));
		genTanh1SVE(p1, z0, z1, z2, z3, log2, log2_e, expCoeff);
		st1w(z0.s, p1, ptr(dst));

		ret();
	}
};

template<size_t dummy = 0>
struct Inst {
	static const Code code;
};

template<size_t dummy>
alignas(32) const Code Inst<dummy>::code;

} // fmath::local

inline void expf_v(float *dst, const float *src, size_t n)
{
	local::Inst<>::code.expf_v(dst, src, n);
}

inline void tanhf_v(float *dst, const float *src, size_t n)
{
	local::Inst<>::code.tanhf_v(dst, src, n);
}

} // fmath2
